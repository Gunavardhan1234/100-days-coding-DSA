# 100-days-coding-DSA

This plan is structured into four phases, progressively building your knowledge from 
fundamentals to advanced topics. Remember, consistency and understanding are 
more important than just solving problems. 
Phase 1: Fundamentals & Basic Structures (Days 1-25) 
This phase focuses on the building blocks of DSA. 
● Resources: Focus on "Easy" to "Medium" difficulty problems on platforms like 
LeetCode, HackerRank, or GeeksforGeeks. 
Days 1-7: Arrays & Strings Basics 
● Concepts: Array manipulation, basic string operations, two-pointers, prefix sums, 
frequency counting. 
● Problem Types: Finding duplicates, reversing arrays/strings, checking 
palindromes, anagrams, array rotations, smallest/largest elements, string 
compression (simple), counting character frequencies. 
● Day 1 (Beginner Focus): 
○ Question 1: Reverse an array/string. (Easy) 
○ Question 2: Check if a string is a palindrome. (Easy) 
○ Question 3 (Optional): Find the largest/smallest element in an array. (Easy) 
Days 8-14: Linked Lists & Stacks/Queues 
● Concepts: Singly linked lists (traversal, insertion, deletion), basic stack operations 
(LIFO), basic queue operations (FIFO), array-based stack/queue implementation. 
● Problem Types: Reversing a linked list, merging two sorted lists (simple), 
detecting a cycle in a linked list, valid parentheses using stack, implementing a 
queue using two stacks. 
Days 15-20: Hashing & Basic Searching/Sorting 
● Concepts: Hash Maps/Sets (dictionaries in Python), their use for efficient 
lookups, frequency counting. Binary Search, introduction to common sorting 
algorithms (Bubble, Insertion, Selection - understand concepts, but use sort() for 
actual problems unless asked to implement). 
● Problem Types: Two Sum, group anagrams, finding unique elements, first 
non-repeating character, implementing binary search, finding Kth largest/smallest 
element (can use sorting). 
Days 21-25: Recursion & Backtracking Intro (Simple) 
● Concepts: Understanding recursion, base cases, recursive step. Basic 
backtracking for simple problems. 
● Problem Types: Factorial, Fibonacci sequence, power of a number, printing 
permutations of a string (short string), N-Queens (simpler version or 
understanding). 
Phase 2: Intermediate Structures & Techniques (Days 26-60) 
This phase delves deeper into more complex data structures and algorithmic 
paradigms. 
● Resources: "Medium" difficulty problems primarily. 
Days 26-35: Trees (Binary Trees & BSTs) 
● Concepts: Binary Tree traversals (Inorder, Preorder, Postorder - iterative and 
recursive), properties of binary trees, Binary Search Trees (BST) - insertion, 
deletion, search, validation. 
● Problem Types: Max depth of binary tree, diameter of binary tree, invert binary 
tree, validate BST, lowest common ancestor (LCA) in BST. 
Days 36-45: Graphs (BFS & DFS) 
● Concepts: Graph representation (Adjacency List/Matrix), Breadth-First Search 
(BFS), Depth-First Search (DFS), connected components, cycle detection 
(undirected graphs). 
● Problem Types: Clone graph, number of islands, course schedule (simple), 
BFS/DFS traversal of a graph, detect cycle in a graph. 
Days 46-55: Heaps & Priority Queues 
● Concepts: Min-heap, Max-heap, Priority Queue implementation and applications. 
● Problem Types: Kth largest element in a stream, merge K sorted lists, top K 
frequent elements, finding median in a data stream. 
Days 56-60: Sliding Window & Greedy Algorithms 
● Concepts: Fixed and variable size sliding window for array/string problems. Basic 
greedy choices. 
● Problem Types: Maximum sum subarray (Kadane's algorithm), longest substring 
without repeating characters, best time to buy and sell stock, activity selection 
problem. 
Phase 3: Advanced Algorithms & Complexities (Days 61-85) 
This phase introduces more advanced topics that often appear in interviews. 
● Resources: "Medium" to "Hard" difficulty problems. 
Days 61-70: Dynamic Programming (DP) - Introduction 
● Concepts: Overlapping subproblems, optimal substructure, memoization 
(top-down), tabulation (bottom-up). Start with classic DP patterns. 
● Problem Types: Climbing Stairs, Coin Change, House Robber, Longest Common 
Subsequence, Knapsack (0/1). Focus on understanding the recurrence 
relation and state definition. 
Days 71-75: Advanced Graph Algorithms 
● Concepts: Dijkstra's Algorithm (shortest path, positive weights), Bellman-Ford 
(shortest path, negative weights), Floyd-Warshall (all-pairs shortest path). 
● Problem Types: Network delay time (Dijkstra), find the city with the smallest 
number of neighbors. 
Days 76-80: Minimum Spanning Trees (MST) & Disjoint Set Union (DSU) 
● Concepts: Prim's Algorithm, Kruskal's Algorithm. Disjoint Set Union (Union-Find) 
with path compression and union by rank/size. 
● Problem Types: Connecting cities with minimum cost, number of connected 
components in an undirected graph, checking for cycles in a graph using DSU. 
Days 81-85: Tries & Bit Manipulation 
● Concepts: Trie (Prefix Tree) data structure for efficient prefix searching. Basic 
bitwise operations (AND, OR, XOR, NOT, shifts). 
● Problem Types: Implement a Trie, implement startsWith, word search with 
prefixes, single number (using XOR), counting set bits. 
Phase 4: Mixed Practice & Review (Days 86-100) 
This final phase is about consolidating knowledge, tackling harder variations, and 
practicing mixed problems under timed conditions. 
● Resources: "Hard" difficulty problems, competitive programming contest 
problems, mock interviews. 
Days 86-90: Advanced Dynamic Programming 
● Concepts: Tree DP, DP with bitmasking, more complex state transitions, DP on 
grids. 
● Problem Types: Palindromic substrings, edit distance, regular expression 
matching (more advanced), unique paths. 
Days 91-95: Mixed DSA Problems & Review 
● Concepts: Random problems covering all topics. Identify your weak areas and 
spend extra time on them. 
● Problem Types: Any combination of data structures and algorithms. Focus on 
identifying the underlying pattern. 
Days 96-100: Mock Interviews & Contest Practice 
● Concepts: Apply all learned techniques under time pressure. Practice explaining 
your thought process and solution. 
● Problem Types: Solve a few LeetCode "Hard" problems daily. Participate in 
weekly contests on LeetCode/HackerRank. Practice explaining solutions verbally. 
Review common interview questions. 
Tips for Success: 
1. Understand, Don't Just Memorize: For every problem, understand why a 
particular approach works and its time/space complexity. 
2. Use Python's Strengths: Leverage Python's built-in data structures (lists as 
dynamic arrays, dictionaries for hash maps, collections module for deque, 
Counter, etc.). 
3. Code Cleanly: Write readable and well-commented code. 
4. Test Thoroughly: Test with edge cases (empty input, single element, max 
constraints). 
5. Review Solutions: Even if you solve a problem, look at optimal solutions from 
others to learn new approaches or optimizations. 
6. Consistency is Key: Stick to the daily practice, even if it's just one problem on a 
busy day. 
7. Don't Get Discouraged: Some problems will be hard. It's okay to look at hints or 
solutions when stuck, but try for a reasonable amount of time first (e.g., 30-60 
minutes). 
8. Track Your Progress: Use a spreadsheet or LeetCode's built-in tracking to see 
your solved problems and identify areas for improvement. 
9. Explain It Out Loud: Try explaining your solution to a rubber duck or a friend. 
This solidifies your understanding. 
10. Take Breaks: If you feel burnt out, a short break can help you come back 
refreshed. This plan is flexible; adjust if needed, but try to keep the momentum. 
Good luck with your 100-day challenge! This systematic approach will significantly 
boost your DSA skills.
